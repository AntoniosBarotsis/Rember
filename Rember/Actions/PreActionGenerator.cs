using Rember.FileStuff;
using Rember.Tasks;

namespace Rember.Actions;

public class PreActionGenerator
{
    public PreActionGenerator(BuildTool buildTool, Type type)
    {
        Text = LoadText();
        Type = type;
        BuildTool = buildTool;
    }

    public string Text { get; private set; }
    private HookAccessor? HookAccessor { get; set; }
    private Type Type { get; }
    private BuildTool BuildTool { get; }

    public PreActionGenerator AddBuildScript()
    {
        Generate(BuildTool.Build.GetName(), BuildTool.Build.GetCommand());
        return this;
    }

    public PreActionGenerator AddTestScript()
    {
        Generate(BuildTool.Test.GetName(), BuildTool.Test.GetCommand());
        return this;
    }

    public PreActionGenerator AddCustom(ConcreteTask customTask)
    {
        Generate(customTask.GetName(), customTask.GetCommand());
        return this;
    }

    // TODO Ask user if they want to build/test instead of enforcing it every time.
    private void Generate(string name, string command)
    {
        var shebang = Text == "" ? "#!/bin/sh\n" : "";
        var inputName = name + "Input";
        var metadata = Text == ""
            ? @$"# Info generated by Rember, do not edit!
#bt:{BuildTool.Name}
#
"
            : "";

        var res = @$"{shebang}
{metadata}
exec < /dev/tty

echo """"
echo ""Do you want to run {name}? [Y/n]""
read {inputName}

if [ -z ${inputName} ] || [ ${inputName} = ""Y"" ] || [ ${inputName} = ""y"" ]
then
    echo ""==============""
    echo ""Running {name} ({command})""
    {command} &> /dev/null
    status=$?

    if [ $status -eq 1 ]
    then
        echo ""{name} failed, exiting...""
    exit $status
        fi

    echo ""{name} passed!""
    echo ""==============""
    echo """"
    echo """"  
fi
";

        Text += res;
    }

    private string LoadText()
    {
        var path = Directory.GetCurrentDirectory() + $"/.git/hooks/pre-{Type.ToString().ToLower()}";
        if (File.Exists(path) && Text is null or "")
        {
            return File.ReadAllText(path);
        }

        return "";
    }

    public void WriteToFile()
    {
        var path = Directory.GetCurrentDirectory() + $"/.git/hooks/pre-{Type.ToString().ToLower()}";
        HookAccessor ??= new HookAccessor(path, Text);
        HookAccessor.SaveChanges();
    }
    
    // public void AppendToFile()
    // {
    //     var path = Directory.GetCurrentDirectory() + $"/.git/hooks/pre-{Type.ToString().ToLower()}";
    //     HookAccessor ??= new HookAccessor(path);
    //     HookAccessor.Text += "\n" + Text;
    //     HookAccessor.SaveChanges();
    // }
}

public enum Events
{
    Unspecified,
    Build,
    Tests
}

public enum Type
{
    Commit,
    Push
}